#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 rectCenter;
    vec2 rectSize;
    float outerThickness;
    float innerThickness;
} pushC;

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);
    vec2 halfSize = pushC.rectSize * 0.5;
    vec2 minP = pushC.rectCenter - halfSize;
    vec2 maxP = pushC.rectCenter + halfSize;

    // Outside rect: fully transparent
    if (frag.x < minP.x || frag.x > maxP.x || frag.y < minP.y || frag.y > maxP.y) {
        imageStore(outImage, pixel, vec4(0.0));
        return;
    }

    float distLeft = frag.x - minP.x;
    float distRight = maxP.x - frag.x;
    float distTop = maxP.y - frag.y;
    float distBottom = frag.y - minP.y;
    float minEdge = min(min(distLeft, distRight), min(distTop, distBottom));

    vec4 color = vec4(0.0);
    if (minEdge <= pushC.outerThickness) {
        color = vec4(0.0, 0.0, 0.0, 1.0); // 3px outer black
    } else if (minEdge <= (pushC.outerThickness + pushC.innerThickness)) {
        color = vec4(1.0, 1.0, 1.0, 1.0); // 3px inner white
    }

    imageStore(outImage, pixel, color);
}
