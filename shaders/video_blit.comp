#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;
layout(set = 0, binding = 1) uniform sampler2D texOverlay;      // rectangle overlay
layout(set = 0, binding = 2) uniform sampler2D texFpsOverlay;   // text overlay
layout(set = 0, binding = 3) uniform sampler2D texLuma;
layout(set = 0, binding = 4) uniform sampler2D texChroma;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 videoSize;
    vec2 targetOrigin;
    vec2 targetSize;
    vec2 cropOrigin;
    vec2 cropSize;
    vec2 chromaDiv;
    uint colorSpace;
    uint colorRange;
    uint overlayEnabled;
    uint fpsOverlayEnabled;
    vec2 overlayOrigin;
    vec2 overlaySize;
    vec2 fpsOverlayOrigin;
    vec2 fpsOverlaySize;
    float scrubProgress;
    float scrubPlaying;
    uint scrubberEnabled;
    uint padScrub0;
    uint padScrub1;
    uint padScrub2;
    vec4 grading;    // exposure, contrast, saturation, pad
    vec4 shadows;    // rgb, w unused
    vec4 midtones;   // rgb, w unused
    vec4 highlights; // rgb, w unused
} pushC;

const float kLumaOffset = 16.0 / 255.0;
const float kLumaScaleLimited = 255.0 / 219.0;
const float kChromaScaleLimited = 255.0 / 224.0;

float convertLuma(float ySample, uint rangeFlag) {
    if (rangeFlag == 0u) {
        return clamp((ySample - kLumaOffset) * kLumaScaleLimited, 0.0, 1.0);
    }
    return ySample;
}

vec2 convertChroma(vec2 uvSample, uint rangeFlag) {
    if (rangeFlag == 0u) {
        return (uvSample - vec2(0.5)) * kChromaScaleLimited;
    }
    return uvSample - vec2(0.5);
}

vec3 yuvToRgb(float y, float u, float v, uint colorSpace) {
    vec3 rgb;
    if (colorSpace == 2u) {          // BT.2020
        rgb.r = y + 1.4746 * v;
        rgb.g = y - 0.164553 * u - 0.571353 * v;
        rgb.b = y + 1.8814 * u;
    } else if (colorSpace == 1u) {   // BT.709
        rgb.r = y + 1.5748 * v;
        rgb.g = y - 0.187324 * u - 0.468124 * v;
        rgb.b = y + 1.8556 * u;
    } else {                         // BT.601
        rgb.r = y + 1.402 * v;
        rgb.g = y - 0.344136 * u - 0.714136 * v;
        rgb.b = y + 1.772 * u;
    }
    return clamp(rgb, 0.0, 1.0);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);

    // Default to background
    // Start with a solid green so overlay visibility is obvious
    vec4 color = vec4(0.0, 1.0, 0.0, 1.0);

    // Sample video in its target region
    bool inVideo = frag.x >= pushC.targetOrigin.x &&
                   frag.y >= pushC.targetOrigin.y &&
                   frag.x <= (pushC.targetOrigin.x + pushC.targetSize.x) &&
                   frag.y <= (pushC.targetOrigin.y + pushC.targetSize.y);

    if (inVideo) {
        vec2 localUV = (frag - pushC.targetOrigin) / pushC.targetSize;
        vec2 videoUV = pushC.cropOrigin + localUV * pushC.cropSize;

        float ySample = texture(texLuma, videoUV).r;
    vec2 uvSample = texture(texChroma, videoUV).rg;
        vec2 uv = convertChroma(uvSample, pushC.colorRange);
        float y = convertLuma(ySample, pushC.colorRange);
        vec3 rgb = yuvToRgb(y, uv.x, uv.y, pushC.colorSpace);
        // Apply grading: contrast then exposure, then saturation
        rgb = rgb * pushC.grading.y + vec3(pushC.grading.x);
        float luma = dot(rgb, vec3(0.299, 0.587, 0.114));
        rgb = mix(vec3(luma), rgb, pushC.grading.z);
        // Shadows / midtones / highlights weighting
        float shadowW = clamp(1.0 - luma * 2.0, 0.0, 1.0);
        float highlightW = clamp((luma - 0.5) * 2.0, 0.0, 1.0);
        float midW = clamp(1.0 - abs(luma - 0.5) * 2.0, 0.0, 1.0);
        rgb *= mix(vec3(1.0), vec3(pushC.shadows), shadowW);
        rgb *= mix(vec3(1.0), vec3(pushC.midtones), midW);
        rgb *= mix(vec3(1.0), vec3(pushC.highlights), highlightW);
        rgb = clamp(rgb, 0.0, 1.0);
        color = vec4(rgb, 1.0);
    }

    // Scrubber (optionally disabled)
    if (pushC.scrubberEnabled != 0u) {
        vec2 scrubSize = vec2(512.0, 64.0);
        float margin = 20.0;
        vec2 scrubOrigin = vec2((pushC.outputSize.x - scrubSize.x) * 0.5, pushC.outputSize.y - scrubSize.y - margin);
        bool inScrub = frag.x >= scrubOrigin.x &&
                       frag.y >= scrubOrigin.y &&
                       frag.x <= (scrubOrigin.x + scrubSize.x) &&
                       frag.y <= (scrubOrigin.y + scrubSize.y);
        if (inScrub) {
            vec2 uv = (frag - scrubOrigin) / scrubSize;
            // Background bar
            vec3 bg = vec3(0.08, 0.08, 0.08);
            vec3 fill = vec3(0.95, 0.45, 0.1);
            vec3 paused = vec3(0.2, 0.6, 1.0);
            vec3 fg = mix(paused, fill, pushC.scrubPlaying);
            float barH = 0.35;
            float yRel = abs(uv.y - 0.5);
            float band = step(yRel, barH * 0.5);
            float prog = clamp(pushC.scrubProgress, 0.0, 1.0);
            float xProg = uv.x <= prog ? 1.0 : 0.0;
            vec3 bar = mix(bg, fg, band * xProg);
            // Handle
            float handleX = prog;
            float handleRadius = 0.12;
            float dist = length(uv - vec2(handleX, 0.5));
            float handle = smoothstep(handleRadius, handleRadius * 0.7, handleRadius - dist);
            vec3 handleCol = vec3(1.0, 0.95, 0.4);
            // draw an outline ring to make the handle obvious
            float ring = smoothstep(handleRadius + 0.025, handleRadius, dist);
            vec3 ringColor = vec3(0.1, 0.1, 0.1);
            vec3 handleLayer = mix(bar, ringColor, ring);
            vec3 handleFill = mix(handleLayer, handleCol, handle);
            vec3 scrubColor = handleFill;
            color = vec4(scrubColor, 1.0);
        }

        // Play/pause icon to the left of the scrubber
        vec2 iconSize = vec2(28.0, 28.0);
        vec2 iconOrigin = scrubOrigin + vec2(-36.0, (scrubSize.y - iconSize.y) * 0.5);
        bool inIcon = frag.x >= iconOrigin.x &&
                      frag.y >= iconOrigin.y &&
                      frag.x <= (iconOrigin.x + iconSize.x) &&
                      frag.y <= (iconOrigin.y + iconSize.y);
        if (inIcon) {
            vec2 uvIcon = (frag - iconOrigin) / iconSize;
            float alphaIcon = 0.0;
            if (pushC.scrubPlaying > 0.5) {
                // Pause: two vertical bars
                float barW = 0.22;
                float gap = 0.12;
                bool leftBar = uvIcon.x > gap && uvIcon.x < (gap + barW);
                bool rightBar = uvIcon.x > (1.0 - gap - barW) && uvIcon.x < (1.0 - gap);
                if ((leftBar || rightBar) && uvIcon.y > 0.1 && uvIcon.y < 0.9) {
                    alphaIcon = 1.0;
                }
            } else {
                // Play: right-pointing triangle
                if (uvIcon.x > 0.18 && uvIcon.x < 0.85) {
                    float t = (uvIcon.x - 0.18) / 0.67;
                    float yTop = mix(0.1, 0.9, t);
                    float yBot = mix(0.9, 0.1, t);
                    if (uvIcon.y > yBot && uvIcon.y < yTop) {
                        alphaIcon = 1.0;
                    }
                }
            }
            if (alphaIcon > 0.0) {
                vec3 iconColor = vec3(1.0);
                color = mix(color, vec4(iconColor, 1.0), alphaIcon);
            }
        }
    }

    // Overlay on top; if enabled and inside overlay region, alpha blend overlay texel
    if (pushC.overlayEnabled != 0u) {
        bool inOverlay = frag.x >= pushC.overlayOrigin.x &&
                         frag.y >= pushC.overlayOrigin.y &&
                         frag.x <= (pushC.overlayOrigin.x + pushC.overlaySize.x) &&
                         frag.y <= (pushC.overlayOrigin.y + pushC.overlaySize.y);
        if (inOverlay) {
            vec2 overlayUV = (frag - pushC.overlayOrigin) / pushC.overlaySize;
            vec4 overlaySample = texture(texOverlay, overlayUV);
            color = mix(color, overlaySample, overlaySample.a);
        }
    }

    // FPS overlay (font-rendered) on top of everything else
    if (pushC.fpsOverlayEnabled != 0u) {
        bool inFps = frag.x >= pushC.fpsOverlayOrigin.x &&
                     frag.y >= pushC.fpsOverlayOrigin.y &&
                     frag.x <= (pushC.fpsOverlayOrigin.x + pushC.fpsOverlaySize.x) &&
                     frag.y <= (pushC.fpsOverlayOrigin.y + pushC.fpsOverlaySize.y);
        if (inFps) {
            vec2 fpsUV = (frag - pushC.fpsOverlayOrigin) / pushC.fpsOverlaySize;
            vec4 fpsSample = texture(texFpsOverlay, fpsUV);
            color = mix(color, fpsSample, fpsSample.a);
        }
    }

    imageStore(outImage, pixel, color);
}
