#version 450
#extension GL_ARB_separate_shader_objects : enable

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly image2D outImage;
layout(set = 0, binding = 1) uniform sampler2D texLuma;
layout(set = 0, binding = 2) uniform sampler2D texChroma;
layout(set = 0, binding = 3) uniform sampler2D texOverlay;

layout(push_constant) uniform Push {
    vec2 outputSize;
    vec2 videoSize;
    vec2 targetOrigin;
    vec2 targetSize;
    vec2 chromaDiv;
    uint colorSpace;
    uint colorRange;
    uint overlayEnabled;
    vec2 overlayOrigin;
    vec2 overlaySize;
} pushC;

const float kLumaOffset = 16.0 / 255.0;
const float kLumaScaleLimited = 255.0 / 219.0;
const float kChromaScaleLimited = 255.0 / 224.0;

float convertLuma(float ySample, uint rangeFlag) {
    if (rangeFlag == 0u) {
        return clamp((ySample - kLumaOffset) * kLumaScaleLimited, 0.0, 1.0);
    }
    return ySample;
}

vec2 convertChroma(vec2 uvSample, uint rangeFlag) {
    if (rangeFlag == 0u) {
        return (uvSample - vec2(0.5)) * kChromaScaleLimited;
    }
    return uvSample - vec2(0.5);
}

vec3 yuvToRgb(float y, float u, float v, uint colorSpace) {
    vec3 rgb;
    if (colorSpace == 2u) {          // BT.2020
        rgb.r = y + 1.4746 * v;
        rgb.g = y - 0.164553 * u - 0.571353 * v;
        rgb.b = y + 1.8814 * u;
    } else if (colorSpace == 1u) {   // BT.709
        rgb.r = y + 1.5748 * v;
        rgb.g = y - 0.187324 * u - 0.468124 * v;
        rgb.b = y + 1.8556 * u;
    } else {                         // BT.601
        rgb.r = y + 1.402 * v;
        rgb.g = y - 0.344136 * u - 0.714136 * v;
        rgb.b = y + 1.772 * u;
    }
    return clamp(rgb, 0.0, 1.0);
}

void main() {
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    if (pixel.x >= int(pushC.outputSize.x) || pixel.y >= int(pushC.outputSize.y)) {
        return;
    }

    vec2 frag = vec2(pixel) + vec2(0.5);

    // Default to background
    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);

    // Inside video rectangle?
    bool inVideo = frag.x >= pushC.targetOrigin.x &&
                   frag.y >= pushC.targetOrigin.y &&
                   frag.x <= (pushC.targetOrigin.x + pushC.targetSize.x) &&
                   frag.y <= (pushC.targetOrigin.y + pushC.targetSize.y);

    if (inVideo) {
        vec2 videoUV = (frag - pushC.targetOrigin) / pushC.targetSize;

        float ySample = texture(texLuma, videoUV).r;
        vec2 uvSample = texture(texChroma, videoUV).rg;
        vec2 uv = convertChroma(uvSample, pushC.colorRange);
        float y = convertLuma(ySample, pushC.colorRange);
        vec3 rgb = yuvToRgb(y, uv.x, uv.y, pushC.colorSpace);
        color = vec4(rgb, 1.0);
    }

    if (pushC.overlayEnabled != 0u) {
        bool inOverlay = frag.x >= pushC.overlayOrigin.x &&
                         frag.y >= pushC.overlayOrigin.y &&
                         frag.x <= (pushC.overlayOrigin.x + pushC.overlaySize.x) &&
                         frag.y <= (pushC.overlayOrigin.y + pushC.overlaySize.y);
        if (inOverlay) {
            vec2 overlayUV = (frag - pushC.overlayOrigin) / pushC.overlaySize;
            vec4 overlay = texture(texOverlay, overlayUV);
            color = mix(color, overlay, overlay.a);
        }
    }

    imageStore(outImage, pixel, color);
}
